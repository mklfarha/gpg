package list

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"go.einride.tech/aip/filtering"
	expr "google.golang.org/genproto/googleapis/api/expr/v1alpha1"	
)

type Implementation struct {	
}

func New() *Implementation {
	return &Implementation{
	}
}

func (i *Implementation) BuildListEntityQuery(ctx context.Context, request ListRequest, entity ListEntity) (string, error) {
	jsonTables := make(map[string]string)
	whereClause, err := buildWhereClauses(
		request.GetFilter().CheckedExpr.Expr,
		entity,
		request.GetFilteringDeclarations(),
		jsonTables)
	if err != nil {
		return "", err
	}

	jsonTablesSlice := []string{}
	for _, jt := range jsonTables {
		jsonTablesSlice = append(jsonTablesSlice, jt)
	}

	jsonTablesFinal := strings.Join(jsonTablesSlice, " ")

	res := fmt.Sprintf("SELECT DISTINCT %s.* FROM %s %s WHERE %s ", entity.EntityIdentifier(), entity.EntityIdentifier(), jsonTablesFinal, whereClause)

	return res, nil
}

func buildWhereClauses(ex *expr.Expr, entity ListEntity, declarations *filtering.Declarations, jsonTables map[string]string) (string, error) {
	cex := ex.GetCallExpr()
	if cex != nil {
		if isBaseFunction(cex.Function) {
			res, err := buildSingleClause(cex, entity, declarations)
			if err != nil {
				return "", nil
			}
			if res.JSONTable != "" {
				if _, found := jsonTables[res.JSONTableName]; !found {
					jsonTables[res.JSONTableName] = res.JSONTable
				}
			}
			return res.ResolvedClause, nil
		}

		operator := ""
		switch cex.Function {
		case filtering.FunctionAnd:
			operator = "AND"
		case filtering.FunctionOr:
			operator = "OR"
		}

		left, err := buildWhereClauses(cex.Args[0], entity, declarations, jsonTables)
		if err != nil {
			return "", err
		}
		right, err := buildWhereClauses(cex.Args[1], entity, declarations, jsonTables)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s %s %s)", left, operator, right), nil
	}
	return "", errors.New("invalid call expression")
}



func buildSingleClause(cex *expr.Expr_Call, entity ListEntity, declarations *filtering.Declarations) (SingleClauseResponse, error) {
	if len(cex.Args) != 2 {
		return SingleClauseResponse{}, errors.New("invalid argument count")
	}
	fieldIdentifier := ""
	isDependant := false
	dependantField := ""
	if cex.Args[0].GetIdentExpr() == nil {
		if cex.Args[0].GetSelectExpr() != nil {
			isDependant = true
			fieldIdentifier = cex.Args[0].GetSelectExpr().GetOperand().GetIdentExpr().GetName()
			dependantField = cex.Args[0].GetSelectExpr().GetField()
		}
	} else {
		fieldIdentifier = cex.Args[0].GetIdentExpr().Name
	}

	request := SingleClauseRequest{
		cex:                     cex,
		declarations:            declarations,
		fieldIdentifier:         fieldIdentifier,
		isDependant:             isDependant,
		dependantFieldIdentifer: dependantField,
	}

	fieldMap := entity.FieldIdentfierToTypeMap()
	fieldType := fieldMap[fieldIdentifier]
	return handleClauseByType(request, entity, fieldType)
}

func isBaseFunction(f string) bool {
	if f == filtering.FunctionEquals ||
		f == filtering.FunctionGreaterEquals ||
		f == filtering.FunctionGreaterThan ||
		f == filtering.FunctionLessEquals ||
		f == filtering.FunctionLessThan ||
		f == filtering.FunctionNot ||
		f == filtering.FunctionNotEquals ||
		f == filtering.FunctionHas ||
		f == filtering.FunctionDuration ||
		f == filtering.FunctionTimestamp {
		return true
	}
	return false
}

