package repository

import (
	"context"
	"fmt"

	entitytypes "{{.ProjectName}}/core/entity/types"

	"go.einride.tech/aip/filtering"
	expr "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
	"google.golang.org/protobuf/reflect/protoreflect"
)
type ListEntity interface {
	FieldIdentfierToTypeMap() map[string]entitytypes.FieldType
	DependantFieldIdentifierToTypeMap() map[string]map[string]entitytypes.FieldType
	EntityIdentifier() string
}

type ListRequest interface {
	GetFilter() filtering.Filter
	GetFilteringDeclarations() *filtering.Declarations
}

func (i *Implementation) BuildListEntityQuery(ctx context.Context, request ListRequest, entity ListEntity) (string, error) {
	query := buildQuery(request, entity)
	return query, nil
}

func buildQuery(request ListRequest, entity ListEntity) string {
	res := fmt.Sprintf("SELECT * FROM %s WHERE ", entity.EntityIdentifier())

	whereClause := buildClause(request.GetFilter().CheckedExpr.Expr, entity, request.GetFilteringDeclarations())

	res += whereClause

	return res
}

func buildClause(ex *expr.Expr, entity ListEntity, declarations *filtering.Declarations) string {
	cex := ex.GetCallExpr()
	if isBaseFunction(cex.Function) {
		return buildSingleClause(cex, entity, declarations)
	}

	if cex.Function == filtering.FunctionAnd {
		return fmt.Sprintf("(%s AND %s)", buildClause(cex.Args[0], entity, declarations), buildClause(cex.Args[1], entity, declarations))
	}

	if cex.Function == filtering.FunctionOr {
		return fmt.Sprintf("(%s OR %s)", buildClause(cex.Args[0], entity, declarations), buildClause(cex.Args[1], entity, declarations))
	}

	return cex.Function
}

func isBaseFunction(f string) bool {
	if f == filtering.FunctionEquals ||
		f == filtering.FunctionGreaterEquals ||
		f == filtering.FunctionGreaterThan ||
		f == filtering.FunctionLessEquals ||
		f == filtering.FunctionLessThan ||
		f == filtering.FunctionNot ||
		f == filtering.FunctionNotEquals ||
		f == filtering.FunctionHas ||
		f == filtering.FunctionDuration ||
		f == filtering.FunctionTimestamp {
		return true
	}
	return false
}

func buildSingleClause(cex *expr.Expr_Call, entity ListEntity, declarations *filtering.Declarations) string {
	if len(cex.Args) != 2 {
		return ""
	}
	fieldIdentifier := ""
	isDependant := false
	dependantField := ""
	if cex.Args[0].GetIdentExpr() == nil {
		if cex.Args[0].GetSelectExpr() != nil {
			isDependant = true
			fieldIdentifier = cex.Args[0].GetSelectExpr().GetOperand().GetIdentExpr().GetName()
			dependantField = cex.Args[0].GetSelectExpr().GetField()
		}
	} else {
		fieldIdentifier = cex.Args[0].GetIdentExpr().Name
	}

	request := SingleClauseRequest{
		cex:                     cex,
		declarations:            declarations,
		fieldIdentifier:         fieldIdentifier,
		isDependant:             isDependant,
		dependantFieldIdentifer: dependantField,
	}

	fieldMap := entity.FieldIdentfierToTypeMap()
	fieldType := fieldMap[fieldIdentifier]
	return handleClauseByType(request, entity, fieldType)
}

func handleClauseByType(req SingleClauseRequest, entity ListEntity, fieldType entitytypes.FieldType) string {
	switch fieldType {
	case entitytypes.StringFieldType, entitytypes.UUIDFieldType:
		return buildStringClause(req)
	case entitytypes.SingleEnumFieldType:
		return buildSingleEnumClause(req)
	case entitytypes.SingleDependantEntityFieldType:
		typeMap := entity.DependantFieldIdentifierToTypeMap()
		dependantTypeMap := typeMap[req.fieldIdentifier]
		dependantFieldType := dependantTypeMap[req.dependantFieldIdentifer]
		return handleClauseByType(req, entity, dependantFieldType)
	case entitytypes.MultiDependantEntityFieldType:
		typeMap := entity.DependantFieldIdentifierToTypeMap()
		dependantTypeMap := typeMap[req.fieldIdentifier]
		dependantFieldType := dependantTypeMap[req.dependantFieldIdentifer]
		req.isDependantMulti = true
		return handleClauseByType(req, entity, dependantFieldType)
	}
	return ""
}

type SingleClauseRequest struct {
	cex                     *expr.Expr_Call
	declarations            *filtering.Declarations
	fieldIdentifier         string
	isDependant             bool
	isDependantMulti        bool
	dependantFieldIdentifer string
}

func buildLeftOperator(req SingleClauseRequest) string {
	if req.isDependant {
		return buildJSONExtract(req)
	}
	return req.fieldIdentifier
}

func buildJSONExtract(req SingleClauseRequest) string {
	if req.isDependantMulti {
		return fmt.Sprintf("JSON_EXTRACT(%s, '$[*].%s')", req.fieldIdentifier, req.dependantFieldIdentifer)
	}
	return fmt.Sprintf("JSON_EXTRACT(%s, '$.%s')", req.fieldIdentifier, req.dependantFieldIdentifer)
}

func buildStringClause(req SingleClauseRequest) string {
	cex := req.cex
	left := buildLeftOperator(req)
	switch cex.Function {
	case filtering.FunctionEquals, filtering.FunctionNotEquals:
		return fmt.Sprintf("%s %s '%s'", left, cex.Function, cex.Args[1].GetConstExpr().GetStringValue())
	case filtering.FunctionHas:
		return fmt.Sprintf("%s like '%%%s%%'", left, cex.Args[1].GetConstExpr().GetStringValue())
	}
	return "unsupported function for type string"
}

func buildSingleEnumClause(req SingleClauseRequest) string {
	cex := req.cex
	declarations := req.declarations
	left := buildLeftOperator(req)
	name := req.fieldIdentifier
	if req.isDependant {
		name = fmt.Sprintf("%s.%s", req.fieldIdentifier, req.dependantFieldIdentifer)
	}
	enumType, found := declarations.LookupEnumIdent(name)
	if found {
		value := cex.Args[1].GetIdentExpr().Name
		numValue := enumType.Descriptor().Values().ByName(protoreflect.Name(value)).Number()
		switch cex.Function {
		case filtering.FunctionEquals, filtering.FunctionNotEquals:
			return fmt.Sprintf("%s %s %d", left, cex.Function, numValue)
		}
		return "unsupported function for type single enum"
	}

	return "enum declaration not found"
}
